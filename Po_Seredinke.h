#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <conio.h>
#include <stdlib.h>
#include <ctype.h>
#include <dir.h>
#define S1 "№"
#define S2 "АВТОР             "
#define S3 "НАЗВАНИЕ                "
#define S4 "ГОД"
#define S5 "КОЛИЧЕСТВО"
#define S6 "СОСТОЯНИЕ  "
//структура которая по сути строка, просто строку нельзя возражать функцией а структуру можно
typedef struct S{
	char s_1[80];
}S;
//печатает на всю консоль '-'
void Ch(int m){
	int i;
	for(i = 0; i<m;i++)
			printf("-");
}
//вывод шапки
void po_krasote(void){
	Ch(125);
	printf(" | %5s | %30s | %40s | %4s | %10s | %15s | ",S1,S2,S3,S4,S5,S6);
	Ch(125);
}
//вывод текста в рамке и по середине консоли
void Po_Seredinke(const char s[],int i){
	int l = strlen(s);//узнаем длину строки
	int n = l;
	int p = (i/2)-(l/2);//так как буфер консоли может вмещать максимально i элементов, то чтобы строка была посередине, то ее нужно сдвинуть на p символов
	for(l = 0;l<p;l++) printf(" ");
	for(l = 0;l<n+2;l++) printf("~");
	printf("\n");
	for(l = 0;l<p;l++) printf(" ");
	printf("|%s|\n",s);
	for(l = 0;l<p;l++) printf(" ");
	for(l = 0;l<n+2;l++) printf("~");
	printf("\n");
}
//кодирование текста
void Edit(char s[]){
	/*если пользователь вводил название книги, которое состоит из двух или более слов, то пробелы между ними заменяем на нижнее подчеркивание
	чтобы потом не было приключений со scanf(он читает до пробельного символа)
	*/
	int n = strlen(s);
	int i;
	for(i = 0; i<n; i++){
		if(s[i] == ' ') s[i] = '_';
	}
}
//декодирование текста
void DeEdit(char s[]){
	int n = strlen(s);
	int i;
	for(i = 0; i<n; i++){
		if(s[i] == '_') s[i] = ' ';
	}
}
//проверяет является ли введенная строка - цифрой
int Cifra_V(char s[]){
	int n = strlen(s);
	int k = 0;
	int i;
	for(i = 0; i<n; i++){
		if((s[i]>=48)&&(s[i]<=57)) k++;//если символ цифра
	}
	//если количество цифр в строке равно длине строки то строка является цифрой
	if(n == k) return 1;
	else return 0;
}
//преобразуем символ в численный ему эквивалент
int Preobr(char s){
	switch(s){
		case '1': return 1; break;
		case '2': return 2; break;
		case '3': return 3; break;
		case '4': return 4; break;
		case '5': return 5; break;
		case '6': return 6; break;
		case '7': return 7; break;
		case '8': return 8; break;
		case '9': return 9; break;
		case '0': return 0; break;
	}
}
//преобразование строки в цифру
int Cifra(char s[]){
	int n = strlen(s);
	int i,j,a=0;
	int l=1;
	for(i=0; i<n;i++){
		for(j=0;j<(n-i-1);j++)//считает разряд
			l*=10;
		a+=Preobr(s[i])*l;//считает число
		l = 1;
	}
	return a;
}
//разрешение на русские символы
int RUS(char b){
	if((b == 'а')||(b == 'А')||(b == 'х')||(b == 'Б')||(b == 'б')||(b == 'В')||(b == 'в')||(b == 'Г')||(b == 'г')||(b == 'Д')
		||(b == 'д')||(b == 'Е')||(b == 'е')||(b == 'Ё')||(b == 'ё')||(b == 'Ж')||(b == 'ж')||(b == 'З')||(b == 'з')||(b == 'И')
	||(b == 'и')||(b == 'Й')||(b == 'й')||(b == 'К')||(b == 'к')||(b == 'Л')||(b == 'л')||(b == 'М')||(b == 'м')||(b == 'Н')
	||(b == 'н')||(b == 'О')||(b == 'о')||(b == 'П')||(b == 'п')||(b == 'Р')||(b == 'р')||(b == 'С')||(b == 'с')||(b == 'Т')
	||(b == 'т')||(b == 'У')||(b == 'у')||(b == 'Ф')||(b == 'ф')||(b == 'Х')||(b == 'х')||(b == 'Ч')||(b == 'ч')||(b == 'Ц')||(b == 'ц')||(b == 'Щ')||(b == 'щ')
	||(b == 'ш')||(b == 'Ш')||(b == 'Ь')||(b == 'ь')||(b == 'Ъ')||(b == 'ъ')||(b == 'Ы')||(b == 'ы')||(b == 'Э')||(b == 'э')
	||(b == 'Ю')||(b == 'ю')||(b == 'Я')||(b == 'я')) return 1;
	else return 0;
}
//проверка является ли строка полноценным словом в соответствии с поставленной задачей
int Slovo( char s[],int m){
	int n = strlen(s);
	int k = 0,l = 0;
	int i;
	if(n > (m-1)) return 0;//по условию все вводимые строки у нас не более m-1 символов
	//хоть и массив из m символов, но m-й - символ конца строки - '\0'
	if(m == 40) return 1;//в названии книг могут присутствовать различные буквы и цифры
	for(i = 0; i<n; i++){
	if((!isdigit(s[i]))||(s[i] == ' ')||(RUS(s[i]))) k++;//если символ буква или пробел
		//функция isalpha не берет во внимание русские буквы, поэтому пришлось писать функцию
		if(s[i] == ' ') l++;//если символ пробел
	}
	if(l == n) return 0;//если все символы - пробелы
	if(n == k) return 1;//если все символы только  буквы и пробелы 
	else return 0;
}
//ограничения на ввод в зависимости от режима
//можно добавлять сколько угодно режимов на свой вкус и в зависимости от конкретной задачи
S Correct(int rezhim){
	S s;
	switch(rezhim){
		case 1:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1) {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=48)&&(s.s_1[0]<=56)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");//и в заданном диапазоне(смотри табл АСКИ)
				}
		}break;
		case 2:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1)  {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=49)&&(s.s_1[0]<=51)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
				}
		}break;
		case 3:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1)  {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=48)&&(s.s_1[0]<=49)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");//и в заданном диапазоне(смотри табл АСКИ)
				}
		}break;
		//для слов которые строго состоят из букв
		case 4:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(!Slovo(s.s_1,30))  {
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//если это не слово то ввести снова
					else {Edit(s.s_1);printf("\n");return s;}//если слово то кодировать и вернуть
				}
		}break;
		//для ввода не более чем 4-х значных цифр
		case 5:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(!Cifra_V(s.s_1)||(strlen(s.s_1)>4))  { 
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//если это не цифра , то ввести снов
					else {printf("\n");return s;}//если цифра то вернуть
				}
		}break;
		case 6:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1)  {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=49)&&(s.s_1[0]<=53)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");//и в заданном диапазоне(смотри табл АСКИ)
				}
		}break;
		case 7:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1)  {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=49)&&(s.s_1[0]<=50)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");//и в заданном диапазоне(смотри табл АСКИ)
				}
		}break;
		case 8:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(strlen(s.s_1)!=1)  {//цифра ведь однозначная должна быть
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");;
						continue;
					}//в этом режиме цифра должна быть однозначной и лежать в соответствующих диапазонах
					if((s.s_1[0]>=48)&&(s.s_1[0]<=55)) {printf("\n");return s;}
					else puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");//и в заданном диапазоне(смотри табл АСКИ)
				}
		}break;
		//для слов которые состоят не только из букв
		case 9:{
				for(;;){
					printf("\n :) Вводите: ");
					gets(s.s_1);
					if(!Slovo(s.s_1,40))  {
						puts("\n\tВвод осуществлен неправильно!\n\tПожалуйста, введите данные еще раз!\n");
						continue;
					}//если это не слово то ввести снова
					else {Edit(s.s_1);printf("\n");return s;}//если слово то кодировать и вернуть
				}
		}break;
	}
}

//нормально отображать ввод и вывод русскими буквами
SmenaCodirovki(){
	
	typedef BOOL ( WINAPI *SETCONSOLEFONT )( HANDLE, DWORD ); // прототип недокументированной функции
	SETCONSOLEFONT SetConsoleFont; 

	HMODULE hmod = GetModuleHandleA( "KERNEL32.DLL" ); // функция здесь 
	SetConsoleFont =( SETCONSOLEFONT ) GetProcAddress( hmod, "SetConsoleFont" ); // берем ее адрес

	if (!SetConsoleFont) { 
		puts("error\n"); 
		exit( 1 ); 
	} // если ошибка 

	SetConsoleFont( GetStdHandle( STD_OUTPUT_HANDLE ),12 ); // устанавливаем 12 шрифт 
	SetConsoleOutputCP( 1251 ); //устанавливаем кодировку 1251
	SetConsoleCP( 1251 );
	system("color F2");//устанавливаем зеленым
}
//структура которая по сути строка, просто строку нельзя возражать функцией а структуру можно
typedef struct S_2{
	char s_1[30];
}S_2;
//вспомогательная функция для библиотек
void BIB(int pm){
	system("dir /a:d /B > bib.txt");//запись всех библиотек в файл bib.txt
	int i=0;
	int k=0;
	char s[30];
	FILE *F;
	F = fopen("bib.txt","a+");
	while(!feof(F)){//считаем сколько всего записей
		fgets(s,31,F);
		k++;
	}//самая последняя запись - мусор системы
	if(k == 1) {puts("\t\tБиблиотек нет.... \n\t\tСоздайте их!");return;}//если есть только мусор системы
	S_2 *a = (S_2 *)malloc(sizeof(S_2)*(k-1));//выделяем память для этих строк
	rewind(F);//идем в начало файла
	while(!feof(F)){//записываем все строки в массив строк
		fgets(a[i].s_1,31,F);
		i++;
		if(i == k-1) break;
	}
	fclose(F);
	remove("bib.txt");//избавляемся от файла
	for(i = 0;i<k-1;i++){//декодируем и выводим на экран библиотеки
		DeEdit(a[i].s_1);
		printf(" %d) %s",i+1,a[i].s_1);
	}
	if(pm == 0) return;//режим в котором нужен просто вывод 
	puts("");
	do{
		i = Cifra(Correct(5).s_1);
	}while(i>k-1);
	Edit(a[i-1].s_1);
	int n = strlen(a[i-1].s_1);
	a[i-1].s_1[n-1] = ' ';//команда dir добавляет им в конец символ новой строки 
	if(pm == 1){//режим открытия
		chdir(a[i-1].s_1);
		DeEdit(a[i-1].s_1);
		printf("\n ~ Библиотека \"%s\" успешно открыта! ~\n",a[i-1].s_1);
	}
	else if(pm == 2){//режим удаления
		rmdir(a[i-1].s_1);
		DeEdit(a[i-1].s_1);
		printf("\n ~ Библиотека \"%s\" успешно удалена! ~\n",a[i-1].s_1);
	}
	else if(pm == 3){//режим редактирования
		puts("\n ~ Введите новое название библиотеки \n");
		strcpy(s,Correct(4).s_1);
		rename(a[i-1].s_1,s);
		DeEdit(a[i-1].s_1);
		printf("\n ~ Библиотека \"%s\" успешно переименована! ~\n",a[i-1].s_1);
	}
}